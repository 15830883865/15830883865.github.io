<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java环境搭建和基本数据类型</title>
      <link href="/2023/02/26/Day01%20java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/02/26/Day01%20java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="java环境搭建和基本数据类型"><a href="#java环境搭建和基本数据类型" class="headerlink" title="java环境搭建和基本数据类型"></a>java环境搭建和基本数据类型</h2><h3 id="java环境搭建"><a href="#java环境搭建" class="headerlink" title="java环境搭建"></a>java环境搭建</h3><h4 id="java编程语言的构成"><a href="#java编程语言的构成" class="headerlink" title="java编程语言的构成"></a>java编程语言的构成</h4><ol><li>JDK: java开发工具包  (开发需要),包括JRE和开发工具 </li><li>JRE:java程序运行的最小环境 (运行java是必要的),包括JVM和API</li><li>JVM :执行java字节码文件的虚拟机</li><li>关系 JDK(JRE(JVM))</li></ol><h4 id="第一个java程序HelloWorld"><a href="#第一个java程序HelloWorld" class="headerlink" title="第一个java程序HelloWorld"></a>第一个java程序HelloWorld</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个java程序 Hello World</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="comment">//main方法,程序的入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//输出语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li><p>单行注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是单行注释</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>文档注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*文档注释：对当前的程序进行说明（功能，编写日期，编写人）</span></span><br><span class="line"><span class="comment">文档注释一般写在类或方法上；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="java运行原理"><a href="#java运行原理" class="headerlink" title="java运行原理"></a>java运行原理</h3><h4 id="Java程序的执行流程"><a href="#Java程序的执行流程" class="headerlink" title="Java程序的执行流程"></a>Java程序的执行流程</h4><ol><li>java源代码（.java）编译以后生成字节码文件(.class)</li><li>字节码文件在java虚拟机上执行</li><li>java虚拟机（JVM）将字节码文件翻译为目标平台可以执行的指令（一次编写，到处运行）</li></ol><h3 id="标识符与数据类型"><a href="#标识符与数据类型" class="headerlink" title="标识符与数据类型"></a>标识符与数据类型</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><h5 id="标识符使用必须遵循一定的规则"><a href="#标识符使用必须遵循一定的规则" class="headerlink" title="标识符使用必须遵循一定的规则"></a>标识符使用必须遵循一定的规则</h5><ol><li>可以包含数字，但是不能以数字开头</li><li>除_ $符号外，不能包含其他特殊字符</li><li>不能使用java关键字或保留字符做标识符</li><li>java标识符大小写敏感</li><li>可以使用汉字，但不推荐，见名知意的起名</li></ol><h5 id="变量的声明及初始化"><a href="#变量的声明及初始化" class="headerlink" title="变量的声明及初始化"></a>变量的声明及初始化</h5><p>变量在第一次使用时要进行初始化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//声明（定义）一个变量 变量的类型 变量名(自己命名的标识符)</span></span><br><span class="line">        <span class="type">int</span> v1=<span class="number">10</span>; <span class="comment">//声明一个int(整数) 类型的变量 变量名是v1,并对其进行初始化，值为10</span></span><br><span class="line">        System.out.println(v1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>分为两大类：基本数据类型和引用数据类型</p><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ol><li>整数类型 byte(1个字节，8位) short（2个字节） int（4个字节） long（8个字节 ）</li><li>浮点类型 float（4个字节） double（8个字节）</li><li>字符类型 char </li><li>布尔类型 boolean</li></ol><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>字面量：计算科学中用于表示源代码中固定值的表示法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字面量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Literal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//3默认就是int类型</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5L</span>; <span class="comment">//5L是long类型的字面量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">6</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5.5</span>; <span class="comment">//小数默认是double类型</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span><span class="number">5.5f</span>; <span class="comment">//float类型</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">e</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="comment">//char 类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">//字符串类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>将小范围数据转换为大范围数据时会自动进行类型转换</p><p>byte -short -char -int -long -float-double</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动类型转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> b= <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; <span class="comment">//byte类型自动转换为int类型</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> i; <span class="comment">//int类型自动转换为long类型</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span>l; <span class="comment">//long类型自动转换为float类型</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> f; <span class="comment">//float类型自动转换为double类型</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span> + <span class="number">5.0</span>; <span class="comment">//整数5在计算过程中自动转换为double,在计算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>将大范围数据转化为小范围数据时,无法自动完成类型转换,需要使用强制类型转换</p><p>强制类型转换可能会出现溢出和精度损失问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制类型转换:范围从大到小的转换</span></span><br><span class="line"><span class="comment"> * 会出现两个风险:溢出和精度损失</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForedConversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> (<span class="type">byte</span>) i1; <span class="comment">//int 强制类型转换成 byte 范围内的数据可以转换成功</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> -<span class="number">129</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> (<span class="type">byte</span>) i2; <span class="comment">//超过了有效范围,会出现溢出问题</span></span><br><span class="line">        System.out.println(b2);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span><span class="number">5.0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> (<span class="type">long</span>) d1;</span><br><span class="line">        System.out.println(l1);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span><span class="number">5.1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> (<span class="type">long</span>) d2; <span class="comment">//精度损失</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop大数据技术原理与应用</title>
      <link href="/2023/02/21/hadoop%E5%85%A5%E9%97%A8/"/>
      <url>/2023/02/21/hadoop%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="hadoop入门"><a href="#hadoop入门" class="headerlink" title="hadoop入门"></a>hadoop入门</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h5><ol><li>分布式系统基础架构</li><li>主要解决海量数据的存储和海量数据的分析计算问题</li></ol><h5 id="Hadoop发展历史"><a href="#Hadoop发展历史" class="headerlink" title="Hadoop发展历史"></a>Hadoop发展历史</h5><h5 id="Hadoop的三大发行版本"><a href="#Hadoop的三大发行版本" class="headerlink" title="Hadoop的三大发行版本"></a>Hadoop的三大发行版本</h5><ol><li>Apache 对于入门学习最好</li><li>Cloudera 内部集成了很多大数据框架  对应产品 CDH</li><li>Hortonworks 文档较好， 对应产品 HDP</li></ol><h5 id="Hadoop的优势"><a href="#Hadoop的优势" class="headerlink" title="Hadoop的优势"></a>Hadoop的优势</h5><ol><li>高可靠性：Hadoop底层维护多个数据副本</li><li>高扩展性</li><li>高效性：Hadoop是并行工作的</li><li>高容错性：能够自动将失败的任务重新分配</li></ol><h5 id="Hadoop的组成"><a href="#Hadoop的组成" class="headerlink" title="Hadoop的组成"></a>Hadoop的组成</h5><ol><li>Common（辅助工具）</li><li>HDFS（数据存储）<ol><li>NameNode  数据存储在什么位置</li><li>2NN 辅助NameNode工作，每隔一段时间对NameNode元数据备份</li><li>DataNode 具体存储数据</li></ol></li><li>YARN(资源调度)<ol><li>ResourceManager:整个集群资源（内存、cpu等）的管理者，老大</li><li>NodeManager：单个节点服务器资源的管理者</li><li>ApplicationMaster：单个任务运行的管理者</li><li>Container：容器，相当于一台独立的服务器，里面封装了任务运行所需要的资源</li><li>客户端可以用多个 可以运行多个ApplicationMaster 每个NodeManager上可以有多个Container</li></ol></li><li>MapReduce(计算)<ol><li>Map阶段并行处理输入数据</li><li>Reduce阶段对Map结果进行汇总</li></ol></li><li>三者关系：</li></ol><h5 id="Hadoop大数据技术生态体系"><a href="#Hadoop大数据技术生态体系" class="headerlink" title="Hadoop大数据技术生态体系"></a>Hadoop大数据技术生态体系</h5><ol><li>数据库（结构化数据）Sqoop数据传递</li><li>文件日志（半结构化数据）Flume日志收集</li><li>视频、ppt等（非结构化数据）Kafka消息队列</li></ol><h5 id="推荐系统案例"><a href="#推荐系统案例" class="headerlink" title="推荐系统案例"></a>推荐系统案例</h5><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><h5 id="模板虚拟机的准备"><a href="#模板虚拟机的准备" class="headerlink" title="模板虚拟机的准备"></a>模板虚拟机的准备</h5><h5 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h5><h5 id="安装JDK-Hadoop"><a href="#安装JDK-Hadoop" class="headerlink" title="安装JDK Hadoop"></a>安装JDK Hadoop</h5><h4 id="Hadoop生产集群搭建"><a href="#Hadoop生产集群搭建" class="headerlink" title="Hadoop生产集群搭建"></a>Hadoop生产集群搭建</h4><h5 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h5><h6 id="xsync集群分布脚本"><a href="#xsync集群分布脚本" class="headerlink" title="xsync集群分布脚本"></a>xsync集群分布脚本</h6><p>需求：循环复制文件到所有节点的相同目录下</p><p>实现流程：</p><ol><li><p>在bin 目录下 创建 mkdir bin</p></li><li><p>cd bin&#x2F;</p></li><li><p>vim xsync</p></li><li><pre><code class="shell">#!/bin/bash#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if [ $pcount -lt 1 ]then    echo Not Enough Arguement!    exit;fi#2. 遍历集群所有机器# 也可以采用：# for host in hadoop&#123;102..104&#125;;for host in hadoop102 hadoop103 hadoop104do    echo ====================    $host    ====================    #3. 遍历所有目录，挨个发送    for file in $@    do        #4 判断文件是否存在        if [ -e $file ]        then            #5. 获取父目录            pdir=$(cd -P $(dirname $file); pwd)            echo pdir=$pdir                        #6. 获取当前文件的名称            fname=$(basename $file)            echo fname=$fname                        #7. 通过ssh执行命令：在$host主机上递归创建文件夹（如果存在该文件夹）            ssh $host &quot;mkdir -p $pdir&quot;                        #8. 远程同步文件至$host主机的$USER用户的$pdir文件夹下            rsync -av $pdir/$fname $USER@$host:$pdir        else            echo $file does not exists!        fi    donedone<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###### ssh免密登录配置</span><br><span class="line"></span><br><span class="line">1. 在.ssh目录下运行 ssh-keygen -t rsa</span><br><span class="line">2. 会产生两个文件一个公钥文件一个密钥文件</span><br><span class="line">3. ssh-copy-id hadoop103..hadoop104 第一次输入密码后续就不需要输入密码</span><br><span class="line"></span><br><span class="line">##### 完全分布式集群（开发和面试的重点）</span><br><span class="line"></span><br><span class="line">###### 集群配置</span><br><span class="line"></span><br><span class="line">1. 集群部署规划</span><br><span class="line"></span><br><span class="line">   NameNode和SecondaryNamNode不要安装在同一台服务器</span><br><span class="line"></span><br><span class="line">   ResourceManager也很消耗内存，不要和NameNode、SecondaryNameNode配置在同一台机器上</span><br><span class="line"></span><br><span class="line">   |      | Hadoop102               | Hadoop03                         | Hadoop04                        |</span><br><span class="line">   | ---- | ----------------------- | -------------------------------- | ------------------------------- |</span><br><span class="line">   | HDFS | NameNode &lt;br /&gt;DataNode | DataNode                         | SecondaryNameNode&lt;br /&gt;DataNode |</span><br><span class="line">   | YARN | NodeManager             | ResourceManager&lt;br /&gt;NodeManager | NoddeManager                    |</span><br><span class="line"></span><br><span class="line">2. 配置文件说明</span><br><span class="line"></span><br><span class="line">   配置文件分为两大类：默认配置文件和自定义配置文件，只有用户想修改某一默认配置时，才需要修改自定义配置文件，更改相应属性值</span><br><span class="line"></span><br><span class="line">   |  要获取的默认文件  |              文件存放在Hadoop的jar包中的位置               |</span><br><span class="line">   | :----------------: | :--------------------------------------------------------: |</span><br><span class="line">   |  core-default.xml  |         Hadoop-common-版本号.jar/core-default.xml          |</span><br><span class="line">   |  hdfs-default.xml  |          Hadoop-hdfs-版本号.jar/hdfs-default.xml           |</span><br><span class="line">   |  yarn-default.xml  |       Hadoop-yarn-common-版本号.jar/yarn-default.xml       |</span><br><span class="line">   | mapred-default.xml | Hadoop-mapreduce-client-core-版本号.jar/mapred-default.xml |</span><br><span class="line"></span><br><span class="line">3. 配置集群</span><br><span class="line"></span><br><span class="line">   1. 核心配置文件 配置core-site.xml</span><br><span class="line"></span><br><span class="line">      ```xml</span><br><span class="line">      &lt;configuration&gt; </span><br><span class="line">          &lt;!-- 指定 NameNode 的地址 --&gt; </span><br><span class="line">          &lt;property&gt; </span><br><span class="line">              &lt;name&gt;fs.defaultFS&lt;/name&gt; </span><br><span class="line">              &lt;value&gt;hdfs://hadoop102:8020&lt;/value&gt; </span><br><span class="line">          &lt;/property&gt; </span><br><span class="line">        &lt;!-- 指定 hadoop 数据的存储目录 --&gt; </span><br><span class="line">          &lt;property&gt; </span><br><span class="line">              &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; </span><br><span class="line">              &lt;value&gt;/opt/module/hadoop-3.1.3/data&lt;/value&gt; </span><br><span class="line">          &lt;/property&gt; </span><br><span class="line">       </span><br><span class="line">      &lt;/configuration&gt; </span><br></pre></td></tr></table></figure>2. HDFS配置文件 hdfs-site.xml   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- NameNode web 端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- SecondaryNameNode web 端访问地址--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop104:9868<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br></pre></td></tr></table></figure>3. YARN配置文件 yarn-site.xml   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定 MR 走 shuffle --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 指定 ResourceManager 的地址--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 环境变量的继承 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br></pre></td></tr></table></figure>4. MapReduce配置文件 mapred-site.xml   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 指定 MapReduce 程序运行在 Yarn 上 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br></pre></td></tr></table></figure></code></pre></li><li><p>在集群上分发配置好的Hadoop配置文件</p><p>xsync &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;etc&#x2F;hadoop&#x2F;</p></li></ol><h6 id="群起集群并测试"><a href="#群起集群并测试" class="headerlink" title="群起集群并测试"></a>群起集群并测试</h6><ol><li><p>配置workers</p><p>vim &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;etc&#x2F;hadoop&#x2F;workers</p><p>​       在文件中加入以下配置</p><p>hadoop102<br>hadoop103<br>hadoop104</p></li><li><p>启动集群</p><p>如果集群是第一次启动，需要在 hadoop102 节点格式化 NameNode（注意：格式化 NameNode，会产生新的集群 id，导致 NameNode 和 DataNode 的集群 id 不一致，集群找不到已往数据。如果集群在运行过程中报错，需要重新格式化 NameNode 的话，一定要先停止 namenode 和 datanode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化。）</p><p>命令 hdfs namenode -format</p></li></ol><h4 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h4><ol><li>配置 mapred-site.xml<br>   只需在mapred-site.xml配置文件加两个参数：<br>   [root@hadoop102 hadoop]$ vim mapred-site.xml</li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 历史服务器 web 端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>分发配置<br>[root@hadoop102 hadoop]$ xsync   $HADOOP_HOME&#x2F;etc&#x2F;hadoop&#x2F;mapred-site.xml</p></li><li><p>在 hadoop102 启动历史服务器</p><p>先重新启动一下集群，先stop后start</p><p>在启用历史服务器 [leokadia@hadoop102 hadoop]$ mapred –daemon start historyserver</p></li></ol><h4 id="配置日志的聚集"><a href="#配置日志的聚集" class="headerlink" title="配置日志的聚集"></a>配置日志的聚集</h4><ol><li><p>配置yarn-site.xml</p><p>vim yarm-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启日志聚集功能 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置日志聚集服务器地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log.server.url<span class="tag">&lt;/<span class="name">name</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>http://hadoop102:19888/jobhistory/logs<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置日志保留时间为 7 天 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>分发配置</p><p>[leokadia@hadoop102 hadoop]$ xsync $HADOOP_HOME&#x2F;etc&#x2F;hadoop&#x2F;yarn-site.xml</p></li><li><p>关闭 NodeManager 、ResourceManager 和 HistoryServer</p></li></ol><p>   [leokadia@hadoop103 hadoop-3.1.3]$ mapred –daemon stop historyserver</p><ol start="4"><li>启动 NodeManager 、ResourceManage 和 HistoryServer</li></ol><h4 id="hadoop集群启动脚本"><a href="#hadoop集群启动脚本" class="headerlink" title="hadoop集群启动脚本"></a>hadoop集群启动脚本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"> </span><br><span class="line">if [ $# -lt 1 ] </span><br><span class="line">then </span><br><span class="line">    echo &quot;No Args Input...&quot; </span><br><span class="line">    exit ; </span><br><span class="line">fi </span><br><span class="line"> </span><br><span class="line">case $1 in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">        echo &quot; =================== 启动 hadoop 集群 ===================&quot; </span><br><span class="line"> </span><br><span class="line">        echo &quot; --------------- 启动 hdfs ---------------&quot; </span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/start-dfs.sh&quot; </span><br><span class="line">        echo &quot; --------------- 启动 yarn ---------------&quot; </span><br><span class="line">        ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/start-yarn.sh&quot; </span><br><span class="line">        echo &quot; --------------- 启动 historyserver ---------------&quot; </span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon start historyserver&quot; </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">        echo &quot; =================== 关闭 hadoop 集群 ===================&quot; </span><br><span class="line"> </span><br><span class="line">        echo &quot; --------------- 关闭 historyserver ---------------&quot; </span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon stop historyserver&quot; </span><br><span class="line">        echo &quot; --------------- 关闭 yarn ---------------&quot; </span><br><span class="line">        ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/stop-yarn.sh&quot; </span><br><span class="line">        echo &quot; --------------- 关闭 hdfs ---------------&quot; </span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/stop-dfs.sh&quot; </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">    echo &quot;Input Args Error...&quot; </span><br><span class="line">;; </span><br><span class="line">esac </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2023/02/20/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/02/20/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="贪心算法的基本介绍"><a href="#贪心算法的基本介绍" class="headerlink" title="贪心算法的基本介绍"></a>贪心算法的基本介绍</h3><ol><li>贪心算法是指在对问题进行求解时，在每一步选择中都采取最好或最优的选择，从而希望能够导致结果是最好或者最优的算法</li><li>贪心算法得到的结果不一定是最优的结果（有时候会是最优解），但是都是相对近似最优解的结果</li></ol><h3 id="贪心算法案例分析"><a href="#贪心算法案例分析" class="headerlink" title="贪心算法案例分析"></a>贪心算法案例分析</h3><h4 id="贪心算法思路分析"><a href="#贪心算法思路分析" class="headerlink" title="贪心算法思路分析"></a>贪心算法思路分析</h4><ol><li>遍历所有的广播电台，找到一个覆盖了最多未覆盖过的地区的电台</li><li>将这个电台加入到一个集合中，想办法把该电台覆盖的地区在下次比较时去掉</li><li>重复第一步直到覆盖了全部的地区</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 贪心算法 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建广播电台，放入到MAp</span></span><br><span class="line">        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,HashSet&lt;String&gt;&gt;();</span><br><span class="line">        <span class="comment">//将各个电台放入到broadccasts</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入到map</span></span><br><span class="line">        broadcasts.put(<span class="string">&quot;k1&quot;</span>, hashSet1);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;k2&quot;</span>, hashSet2);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;k3&quot;</span>, hashSet3);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;k4&quot;</span>, hashSet4);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;k5&quot;</span>, hashSet5);</span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList ,存放选择的电台集合</span></span><br><span class="line">        ArrayList&lt;String&gt; selects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个临时的集合，在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义maxKey,保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span></span><br><span class="line">        <span class="comment">//如果maxkey 不为null,则会加入到selects</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(allAreas.size()!=<span class="number">0</span>)&#123;<span class="comment">//如果allAreas 不为0，则表示还没有覆盖到所有的地区</span></span><br><span class="line">            <span class="comment">//每进行一次while，需要</span></span><br><span class="line">            maxKey = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//遍历broadcasts，取出对应key</span></span><br><span class="line">            <span class="keyword">for</span> (String key: broadcasts.keySet()</span><br><span class="line">                 ) &#123;</span><br><span class="line">                tempSet.clear();</span><br><span class="line">                <span class="comment">//当前这个key能够覆盖的地区</span></span><br><span class="line">                HashSet&lt;String&gt; areas =broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                <span class="comment">//求出tempSet 和 allAreas 集合的交集，交集会赋给tempSet</span></span><br><span class="line">                tempSet.retainAll(allAreas);</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size()&gt;<span class="number">0</span> &amp;&amp; (maxKey == <span class="literal">null</span> || tempSet.size() &gt;broadcasts.get(maxKey).size()))&#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//maxKey != null, 就应该将maxKey加入selects</span></span><br><span class="line">            <span class="keyword">if</span>(maxKey != <span class="literal">null</span>)&#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">//将maxKey指向的广播电台覆盖的地区，从allAreas去掉</span></span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是&quot;</span>+ selects.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kmp算法</title>
      <link href="/2023/02/20/kmp%E7%AE%97%E6%B3%95%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/02/20/kmp%E7%AE%97%E6%B3%95%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="kmp算法的介绍"><a href="#kmp算法的介绍" class="headerlink" title="kmp算法的介绍"></a>kmp算法的介绍</h3><ol><li>kmp是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li><li>kmp算法又叫做字符串查找算法</li><li>kmp算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</li></ol><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>先得到子串的部分匹配表</li><li>使用部分匹配表完成KMP匹配</li></ol><h3 id="kmp算法代码实现"><a href="#kmp算法代码实现" class="headerlink" title="kmp算法代码实现"></a>kmp算法代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span><span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        <span class="type">int</span>[] next=KmpNext(str2);</span><br><span class="line">        System.out.println(KmpSearch(str1, str2, next));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//kmp搜索算法</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">KmpSearch</span><span class="params">(String str1, String str2,<span class="type">int</span>[] next)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">0</span>; i &lt;str1.length() ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要处理str1.charAt(i)!=str2.charAt(j),去调整j的大小</span></span><br><span class="line">            <span class="comment">//kmp算法核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j))&#123;</span><br><span class="line">                j=next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i)==str2.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j==str2.length())&#123; <span class="comment">//找到了</span></span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取一个字符串（字串）的部分匹配值表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] KmpNext(String dest)&#123;</span><br><span class="line">        <span class="comment">//创建一个next数组保存部分匹配值</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//如果字符串是长度为1部分匹配值就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>,j =<span class="number">0</span>; i &lt;dest.length() ; i++) &#123;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) != dest.charAt(j),我们需要从next[j-1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现有 dest.charAt(i) = dest.charAt(j)成立才退出</span></span><br><span class="line">            <span class="comment">//这是kmp算法的核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; dest.charAt(i)!= dest.charAt(j))&#123;</span><br><span class="line">                j=next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) = dest.charAt(j)满足时，部分匹配值就是+1</span></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i)==dest.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划算法</title>
      <link href="/2023/02/20/%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/02/20/%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>动态规划算法的核心思想是：将大问题划分成小问题进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</li><li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</li><li>动态规划可以通过填表的方式来逐步推进，得到最优解</li></ol><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值更大。其中又分01背包和完全背包（每种物品可以无限件可用）</p><p>这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，c为背包的容量。再令v[i] [J] 表示在前i个物品中能够装入容量为j 的背包中的最大值。则我们有下面的结果：</p><p> v[i] [0] &#x3D; v[0] [j] &#x3D; 0;</p><p>当w[i] &gt;j 时：v[i] [j] &#x3D; v[i-1] [j]</p><p>当j&gt;&#x3D; w[i]时：v[i] [j] &#x3D; max{v[i-1] [j],v[i-1] [j-w[i]]+v[i]} </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 背包问题 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] w =&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;<span class="comment">//记录物品的重量</span></span><br><span class="line">        <span class="type">int</span> [] val =&#123;<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">2000</span>&#125;;<span class="comment">//物品的价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span><span class="number">4</span>;<span class="comment">//背包的容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> val.length; <span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了计录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">        <span class="type">int</span> [][] path = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组，</span></span><br><span class="line">        <span class="type">int</span>[][] v =<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行和第一列，可以不写 默认是零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;v.length ; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;v[<span class="number">0</span>].length ; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;v.length ; i++) &#123; <span class="comment">//不处理第一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;v[<span class="number">0</span>].length ; j++) &#123;<span class="comment">//不处理第一列</span></span><br><span class="line">                <span class="keyword">if</span> (w[i-<span class="number">1</span>]&gt;j)&#123;</span><br><span class="line">                    v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                    v[i][j] =Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i-<span class="number">1</span>][j]&lt;val[i-<span class="number">1</span>]+v[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]])&#123;</span><br><span class="line">                        v[i][j]=val[i-<span class="number">1</span>]+v[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;v.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;v[i].length ; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划算法</title>
      <link href="/2023/02/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>动态规划算法的核心思想是：将大问题划分成小问题进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</li><li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</li><li>动态规划可以通过填表的方式来逐步推进，得到最优解</li></ol><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值更大。其中又分01背包和完全背包（每种物品可以无限件可用）</p><p>这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，c为背包的容量。再令v[i] [J] 表示在前i个物品中能够装入容量为j 的背包中的最大值。则我们有下面的结果：</p><p> v[i] [0] &#x3D; v[0] [j] &#x3D; 0;</p><p>当w[i] &gt;j 时：v[i] [j] &#x3D; v[i-1] [j]</p><p>当j&gt;&#x3D; w[i]时：v[i] [j] &#x3D; max{v[i-1] [j],v[i-1] [j-w[i]]+v[i]} </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 背包问题 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] w =&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;<span class="comment">//记录物品的重量</span></span><br><span class="line">        <span class="type">int</span> [] val =&#123;<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">2000</span>&#125;;<span class="comment">//物品的价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span><span class="number">4</span>;<span class="comment">//背包的容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> val.length; <span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了计录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">        <span class="type">int</span> [][] path = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组，</span></span><br><span class="line">        <span class="type">int</span>[][] v =<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行和第一列，可以不写 默认是零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;v.length ; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;v[<span class="number">0</span>].length ; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;v.length ; i++) &#123; <span class="comment">//不处理第一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;v[<span class="number">0</span>].length ; j++) &#123;<span class="comment">//不处理第一列</span></span><br><span class="line">                <span class="keyword">if</span> (w[i-<span class="number">1</span>]&gt;j)&#123;</span><br><span class="line">                    v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                    v[i][j] =Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i-<span class="number">1</span>][j]&lt;val[i-<span class="number">1</span>]+v[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]])&#123;</span><br><span class="line">                        v[i][j]=val[i-<span class="number">1</span>]+v[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;v.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;v[i].length ; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分治算法</title>
      <link href="/2023/02/10/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/02/10/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="分治算法介绍"><a href="#分治算法介绍" class="headerlink" title="分治算法介绍"></a>分治算法介绍</h3><ol><li><p>分治法是一种很重要的算法。字面上的解释是‘分而治之’，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题。。。。直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础</p></li><li><p>分治算法可以求解一些经典问题</p><ul><li>二分搜索</li><li>大整数算法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li>汉诺塔</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 汉诺塔 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hanoiTower(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoiTower</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span> a, <span class="type">char</span> b,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个盘从&quot;</span>+a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果我们有n&gt;=2情况，我们总是可以看做是两个盘 最下面的一个盘 上面的所有盘</span></span><br><span class="line"><span class="comment">            先把最上面的所有盘A-&gt;B,移动过程会使用到C</span></span><br><span class="line"><span class="comment">            把最下面的盘A-&gt;C</span></span><br><span class="line"><span class="comment">            把B塔的所有盘从B-&gt;C,移动过程使用到a塔</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>,a,c,b);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+num+<span class="string">&quot;个盘从&quot;</span>+a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">            hanoiTower(num-<span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找算法(非递归)</title>
      <link href="/2023/02/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95(%E9%9D%9E%E9%80%92%E5%BD%92)/"/>
      <url>/2023/02/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95(%E9%9D%9E%E9%80%92%E5%BD%92)/</url>
      
        <content type="html"><![CDATA[<h3 id="非递归二分查找介绍"><a href="#非递归二分查找介绍" class="headerlink" title="非递归二分查找介绍"></a>非递归二分查找介绍</h3><ol><li><p>二分查找算法只适用于从有序的数列中进行查找，将数列排序后在进行查找</p></li><li><p>二分查找法的运行时间为对数时间O（log2n），即查找到需要的目标位置最多只需要log2n步。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 二分查找 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">35</span>,<span class="number">57</span>,<span class="number">78</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(run(arr, <span class="number">99</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span>  mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2023/01/24/%E5%9B%BE/"/>
      <url>/2023/01/24/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h3><p>二维数组表示（邻接矩阵）、链表表示（邻接表）数组加链表</p><h3 id="图的创建和代码实现"><a href="#图的创建和代码实现" class="headerlink" title="图的创建和代码实现"></a>图的创建和代码实现</h3><p>存储顶点String 使用 ArrayList</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span>[][] edrges;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> numOfEdges;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试是否创建成功</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String VertexValue[]=&#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (String value: VertexValue</span><br><span class="line">             ) &#123;</span><br><span class="line">            graph.insertVertex(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        edrges =<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges =<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link: edrges</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入节点</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span> <span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2,<span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        edrges[v1][v2] =weight;</span><br><span class="line">        edrges[v2][v1] =weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树</title>
      <link href="/2023/01/17/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
      <url>/2023/01/17/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h3><p>对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大</p><p>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p><h4 id="二叉排序树的创建和遍历"><a href="#二叉排序树的创建和遍历" class="headerlink" title="二叉排序树的创建和遍历"></a>二叉排序树的创建和遍历</h4><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySotrTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr =&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">BinarySortTre</span> <span class="variable">binarySortTre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySortTre</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            binarySortTre.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        binarySortTre.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySortTre</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Node root;</span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为空不能遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值和当前子树根节点的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt;<span class="built_in">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//如果左子节点为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left ==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.left =node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.right =node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树结构实际应用</title>
      <link href="/2023/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8md/"/>
      <url>/2023/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8md/</url>
      
        <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="堆排序的基本介绍"><a href="#堆排序的基本介绍" class="headerlink" title="堆排序的基本介绍"></a>堆排序的基本介绍</h4><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，他的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序</p><p>堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆，注意：没有要求节点的左孩子的值和右孩子节点的值的大小关系。</p><p>每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆</p><h4 id="堆排序的基本思想"><a href="#堆排序的基本思想" class="headerlink" title="堆排序的基本思想"></a>堆排序的基本思想</h4><ol><li>将待排序序列构造成一个大顶堆</li><li>整个序列的最大值就是堆顶的根节点</li><li>将其与末尾元素进行交换，此时末尾就为最大值</li><li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便得到一个有序序列了</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个堆排序的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="comment">//将无序序列构建成一个大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length/<span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将堆顶元素与末尾元素交换，重新调整结构，使其满足堆定义， 然后</span></span><br><span class="line">        <span class="comment">//继续交换堆顶元素与当前末尾元素，反复执行调整</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>arr.length-<span class="number">1</span>; i &gt;<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            temp =arr[i];</span><br><span class="line">            arr[i]=arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>]=temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 表示非叶子节点在数组中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lenght 表示对多少个元素继续调整，lenght 是在逐渐减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个数组，调整成一个大顶堆</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i,<span class="type">int</span> lenght)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">1</span>; j &lt;lenght ; j=j*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span>&lt;lenght &amp;&amp; arr[j] &lt;arr[j+<span class="number">1</span>])&#123; <span class="comment">//说明左子节点的值小于右子节点的值</span></span><br><span class="line">                j++; <span class="comment">//j指向右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt;temp)&#123; <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">                arr[i]=arr[j]; <span class="comment">//把较大的值赋给当前节点</span></span><br><span class="line">                i=j; <span class="comment">// i 指向J 继续循环比较</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp; <span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗简单的二叉树</li><li>取出根节点权值最小的两颗二叉树</li><li>组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点的权值的和</li><li>再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到了一棵赫夫曼树</li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建赫夫曼树的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        遍历arr数组</span></span><br><span class="line"><span class="comment">        将arr的每个元素构成一个Node</span></span><br><span class="line"><span class="comment">        将Node放入到ArrayList中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Node&gt; nodes =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value: arr</span><br><span class="line">             ) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出根节点权值最小的两颗二叉树</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建一颗新的二叉树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(left.value + right.value);</span><br><span class="line">            parent.left = left;</span><br><span class="line">            parent.right = right;</span><br><span class="line"></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建节点类</span></span><br><span class="line"><span class="comment">//为了让Node 对象持续排序Collections集合排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt;&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">( <span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value -o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2023/01/12/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/01/12/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="哈希表介绍"><a href="#哈希表介绍" class="headerlink" title="哈希表介绍"></a>哈希表介绍</h3><p>散列表也叫哈希表，是根据关键码值而直接进行访问的数据结构，也就是说，它通过把关键码值映射到表中一个位置来访问计录，以加快查找的速度。这个映射函数叫做散列函数，存放计录的数组叫做散列表。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTabDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//写一个简单的菜单</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add:添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;list:显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit:退出系统&quot;</span>);</span><br><span class="line"></span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入名字&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                    <span class="comment">//创建雇员</span></span><br><span class="line">                    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(id, name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建哈希表</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">HashTab</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">   <span class="keyword">private</span>  <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">HashTab</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化empLinkedListArray</span></span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="comment">//初始化每一条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;size ; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span>&#123;</span><br><span class="line">        <span class="comment">//根据员工id,得到该员工应当添加到哪条了链表</span></span><br><span class="line">        <span class="type">int</span>  <span class="variable">empLinkedListNO</span> <span class="operator">=</span>hashFun(emp.id);</span><br><span class="line">        <span class="comment">//将emp 添加到对应的链表中</span></span><br><span class="line">        empLinkedListArray[empLinkedListNO].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有的链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;size ; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写散列函数，使用一个简单取模法</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">hashFun</span><span class="params">(<span class="type">int</span> id )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id %size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Emp</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建EmpLinkedList,表示链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmpLinkedList</span>&#123;</span><br><span class="line">    <span class="comment">//头指针，执行第一个Emp,因此我们这个链表的head 是指向第一个Emp</span></span><br><span class="line">    <span class="keyword">private</span> Emp head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员到链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是第一个雇员</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>) &#123;<span class="comment">//说明到链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next; <span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出是直接将emp,加入到链表</span></span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表的雇员信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前链表的信息为&quot;</span>);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head; <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;=&gt;id%d name=%s\t&quot;</span>,curEmp.id,curEmp.name);</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp =curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="二叉树的概念和常用术语"><a href="#二叉树的概念和常用术语" class="headerlink" title="二叉树的概念和常用术语"></a>二叉树的概念和常用术语</h4><ol><li>常用术语：节点 根节点 父节点  子节点 叶子节点（没有子节点的节点） 节点的权。。。。</li><li>每个节点只能有两个子节点的一种形式成为二叉树</li><li>二叉树的子节点分为左节点和右节点</li><li>如果该二叉树的所有叶子节点都在最后一层，并且节点总数为2^n-1,n为层数，则称为满二叉树</li></ol><h4 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h4><ol><li>前序遍历：先输出父节点，在遍历左子树和右子树</li><li>中序遍历：先遍历左子树，在输出父节点，在遍历右子树</li><li>后序遍历：先遍历左子树，在遍历右子树，最后输出父节点</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;songjiang&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;wuyong&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;lujunyi&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;linchong&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node1.setLeft(node2);</span><br><span class="line">        node1.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        binaryTree.setRoot(node1);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后续遍历</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">HeroNode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  HeroNode left;</span><br><span class="line">    <span class="keyword">private</span>  HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后续遍历</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的查找"><a href="#二叉树的查找" class="headerlink" title="二叉树的查找"></a>二叉树的查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrdersearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="comment">//比较当前结点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前节点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="comment">//如果左递归前序查找，找到节点，则返回</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.preOrdersearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.preOrdersearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="comment">//判断当前节点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则继续进行右递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode =<span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h4><ol><li>n个节点的二叉链表中含有n+1【公式2n-(n-1)&#x3D;n+1】个空指针域。利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/2023/01/12/%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/01/12/%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ol><li><p>有序数组进行二分查找</p></li><li><p>二分查找有两种 一种是递归，一种 是非递归</p></li><li><p>二分查找的思路分析</p><ol><li>首先确定该数组的中间的下标 mid &#x3D;(left+right)&#x2F;2</li><li>接着让需要查找的数findVal和arr[mid]比较</li><li>findVal &gt; arr[mid] 说明要找的数在mid右边，需要向右递归查找，findVal &lt; arr[mid] 说明要找的数在mid左边，需要向左递归查找 findVal&#x3D;arr[mid]说明找到，就返回</li><li>当 left&gt;right就需要退出</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(binarySearch(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">88</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> findVal)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span>arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123;<span class="comment">//向右递归</span></span><br><span class="line">         <span class="keyword">return</span> binarySearch(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125;<span class="keyword">else</span>  <span class="keyword">if</span> (findVal &lt; midVal)&#123;</span><br><span class="line">            <span class="keyword">return</span>  binarySearch(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到数组中相同的所有的值 并返回下标 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span>arr[mid];</span><br><span class="line">    <span class="keyword">if</span> (findVal &gt; midVal) &#123;<span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">    &#125;<span class="keyword">else</span>  <span class="keyword">if</span> (findVal &lt; midVal)&#123;</span><br><span class="line">        <span class="keyword">return</span>  binarySearch2(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt;<span class="number">0</span> || arr[temp]!=findVal)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp);</span><br><span class="line">            temp-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(mid);</span><br><span class="line">   </span><br><span class="line">        temp = mid +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;arr.length-<span class="number">1</span> ||arr[temp] != findVal)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp);</span><br><span class="line">            temp += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><ol><li>插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。</li><li>公式为 int mid &#x3D; left +（right - left) *(findVal -arr[left])&#x2F;(arr[right] -arr[left])</li></ol><h3 id="斐波那契查找算法（黄金分割法）"><a href="#斐波那契查找算法（黄金分割法）" class="headerlink" title="斐波那契查找算法（黄金分割法）"></a>斐波那契查找算法（黄金分割法）</h3><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FibonacciSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;;</span><br><span class="line">        System.out.println(fibSearch(arr, <span class="number">1234</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为后面我们 mid = low +F(k-1)-1,需要使用斐波那契数列，因此我们需要先获取一个斐波那契数列</span></span><br><span class="line">    <span class="comment">//非递归实现斐波那契数列</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">int</span>[] fib()&#123;</span><br><span class="line">        <span class="type">int</span> [] f  =<span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i]=f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写斐波那契算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibSearch</span> <span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f[] = fib();<span class="comment">//获取道斐波那契</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt;f[k] -<span class="number">1</span>)&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为f[k]值 可能大于a的长度，因此我们需要使用Arrays类，构建一个新的数组，并指向a[]</span></span><br><span class="line">        <span class="comment">//不足的部分会使用0填充</span></span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(a,f[k]);</span><br><span class="line">        <span class="comment">//实际上需求使用a数组最后的数值填充temp\</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high +<span class="number">1</span> ; i &lt;temp.length ; i++) &#123;</span><br><span class="line">            temp[i] =a[high];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用while来循环处理，找到我们的数key</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123; <span class="comment">//只要这个条件满足，就可以找到</span></span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; temp[mid]) &#123; <span class="comment">//我们应该继续向数组的前面查找（左边）</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; temp[mid]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">if</span> (mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法二</title>
      <link href="/2022/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
      <url>/2022/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E5%85%AD%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ol><li><p>基本介绍</p><p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效率的版本，也称为缩小增量排序。</p></li><li><p>基本思想</p><p>希尔排序是把计录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量的减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 </p></li><li><p>代码实现【交换式】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">sellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一层for循环时每一次的分组情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span>arr.length / <span class="number">2</span>; gap &gt;<span class="number">0</span> ; gap/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>gap; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-gap; j&gt;=<span class="number">0</span> ; j-=gap) &#123;<span class="comment">//遍历各组中所有的元素</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;arr[j+gap])&#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] =arr[j+gap];</span><br><span class="line">                    arr[j+gap] =temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码实现【插入式】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序的插入式</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">sellSort2</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">       <span class="comment">//第一层for循环时每一次的分组情况</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span>arr.length / <span class="number">2</span>; gap &gt;<span class="number">0</span> ; gap/=<span class="number">2</span>) &#123;</span><br><span class="line">           <span class="comment">//从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>gap; i &lt;arr.length; i++) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>i;</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>arr[j];</span><br><span class="line">               <span class="keyword">if</span> (arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                   <span class="keyword">while</span>(j-gap&gt;=<span class="number">0</span> &amp;&amp; temp &lt;arr[j-gap])&#123;</span><br><span class="line">                       <span class="comment">//移动</span></span><br><span class="line">                       arr[j] =arr[j-gap];</span><br><span class="line">                       j-=gap;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">                   arr[j]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li><p>基本介绍</p><p>QuickSort 是对冒泡排序的一种改进。通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对两部分数据分别进行快速排序</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span>left; <span class="comment">//左下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span>right; <span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//pivot 中轴值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> temp= <span class="number">0</span>;<span class="comment">//临时变量，交换使用</span></span><br><span class="line">        <span class="comment">//while 循环的目的是让比pivot值小放到左边</span></span><br><span class="line">        <span class="comment">//比pivot 值大放到右边</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">// 在pivot的左边一直找，找到大于等于pivot值，才退出</span></span><br><span class="line">            <span class="keyword">while</span>(arr[l] &lt; pivot)&#123;</span><br><span class="line">                l +=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在 pivot 的右边一直找，找到小于等于piovt值，才退出</span></span><br><span class="line">            <span class="keyword">while</span>( arr[r] &gt;pivot)&#123;</span><br><span class="line">                r-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if l&gt;=r 说明pivot 的左右两边的已经完成</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现arr[l]=pivot值 相等 l--</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot)&#123;</span><br><span class="line">                r-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r] == pivot 相等l++,后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot)&#123;</span><br><span class="line">                l +=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果l == r,必须l++,r--，否则为出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r)&#123;</span><br><span class="line">            quicksort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l)&#123;</span><br><span class="line">            quicksort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergetSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];<span class="comment">//归并排序需要一个额外的空间</span></span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">//初始化i，左边有序序列的初始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">//初始化就，右边有序序列的初始序列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//指向temp的当前数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（一）</span></span><br><span class="line">        <span class="comment">//先把左右两边有序的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">//继续</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line"><span class="comment">            即将左边的当前元素，填充到temp数组</span></span><br><span class="line"><span class="comment">            然后 t++,i++</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//反之，将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        (二)</span></span><br><span class="line"><span class="comment">        将剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;<span class="comment">//右边的有序序列还有剩余，就全部填充到temp</span></span><br><span class="line">            temp[t] =arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        (三)</span></span><br><span class="line"><span class="comment">        将temp数组的元素拷贝到arr</span></span><br><span class="line"><span class="comment">        注意，并不是每次都要拷贝所有</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempLift</span> <span class="operator">=</span>left;</span><br><span class="line">        <span class="keyword">while</span>(tempLift &lt;= right)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              第一次合并tempLeft = 0, right = 1// tempLeft =2 right =3</span></span><br><span class="line"><span class="comment">              tL=0 ri =3</span></span><br><span class="line"><span class="comment">              最后一次 tempLeft = 0 right =7</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            arr[tempLift] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            tempLift +=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基数排序‘"><a href="#基数排序‘" class="headerlink" title="基数排序‘"></a>基数排序‘</h3><ol><li><p>基本思想</p><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p></li><li><p>第一轮排序： 将每个元素的个位数取出，然后看这个数应该方在哪个对应的桶（一个一维数组）。按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）</p></li><li><p>第二轮排序：将每个元素的十位数取出，然后看这个数应该方在哪个对应的桶（一个一维数组）。按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）</p></li><li><p>第三轮排序：将每个元素的百位数取出，然后看这个数应该方在哪个对应的桶（一个一维数组）。按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）</p></li><li><pre><code class="java">import java.util.Arrays;public class RadixSort &#123;    public static void main(String[] args) &#123;        int arr[] =&#123;53,3,542,748,14,22,435,768&#125;;        radixSort(arr);        System.out.println(Arrays.toString(arr));    &#125;    public static  void radixSort(int[] arr) &#123;        //得到数组中最大的数的位数        int max = arr[0];//假设第一个数就是最大数        for (int i = 0; i &lt; arr.length; i++) &#123;            if (arr[i] &gt; max) &#123;                max = arr[i];            &#125;        &#125;        //得到最大数是几位数        int maxLength = (max + &quot;&quot;).length();        //第一轮：针对每个元素的个位数进行排序处理        //定义一个二维数组，表示十个桶，每个桶就是一个一维数组        /*        1.二维数组包含10个一维数组        2.为了防止在放入数的时候，数据溢出，则每一个一维数组（桶），大小定义为arr.length        3.明确，基数排序是使用空间换时间的经典算法         */        int[][] bucket = new int[10][arr.length];        //为了计录每个桶中，实际存放了多少个数据，我们定义一个一维数组来计录各个桶的每次放入        //的数据的个数        int[] bucketElementCounts = new int[10];        for (int j = 0,n=1; j &lt; maxLength; j++,n*=10) &#123;            //第一轮（针对每个元素的个位进行排序处理）            for (int i = 0; i &lt; arr.length; i++) &#123;                //取出每个元素的个位的值                int digittOfElement = arr[i] /n% 10;                //放入到对应的桶中                bucket[digittOfElement][bucketElementCounts[digittOfElement]] = arr[i];                bucketElementCounts[digittOfElement]++;            &#125;            //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）            int index = 0;            //遍历每一桶，并将桶中的数组，放入原数组            for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;                //如果桶中有数据就放                if (bucketElementCounts[k] != 0) &#123;                    for (int i = 0; i &lt; bucketElementCounts[k]; i++) &#123;                        arr[index++] = bucket[k][i];                    &#125;                &#125;                bucketElementCounts[k] = 0;            &#125;        &#125;    &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2022/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
      <url>/2022/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%BA%94%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="排序算法的介绍"><a href="#排序算法的介绍" class="headerlink" title="排序算法的介绍"></a>排序算法的介绍</h4><ol><li>排序算法是将一组数据，依指定的顺序进行排列的过程</li></ol><h4 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h4><ol><li><p>内部排序</p><p>指将需要处理的所有数据都加载到内部存储器（内存）中进行排序。</p></li><li><p>外部排序法</p><p>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。</p></li></ol><h4 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h4><ol><li>时间频度：一个算法中的语句执行次数称为时间频度T(n)</li><li>常见的时间复杂度<ol><li>常数阶O(1)</li><li>对数阶O(log2n)</li><li>线性阶O(n)</li><li>线性对数阶O(nlog2n)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>K次方阶O(n^k)</li><li>指数阶O(2^n)</li></ol></li></ol><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ol><li><p>基本介绍</p><p>通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，值较大的元素逐渐从前移向后部。</p></li><li><p>冒泡排序规则</p><ol><li>一共进行数组大小-1次大的循环</li><li>每一趟循环的次数在逐渐减少</li><li>如果我们发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序，这个就是优化。</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标识变量，表示是否进行交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> arr[j + <span class="number">1</span>];</span><br><span class="line">                        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                        arr[j] = a;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag != <span class="literal">true</span>) &#123;<span class="comment">//说明一次都没有交换</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>; <span class="comment">//重置flag ,进行下次判断</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>冒泡排序的时间复杂度是O(n^2)</p></li></ol><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ol><li><p>基本介绍</p><p>就是遍历整个数组找到数组当中最小的值并与arr[0] 交换，接着，从arr[1]-arr[n]开始遍历数组，再次找到最小值并和arr[1]交换</p></li><li><p>思路说明</p><ol><li><p>选择排序一共有数组大小-1轮排序</p></li><li><p>每一轮排序，又是一个循环</p><ol><li>先假定当前这个数就是最小数</li><li>然后和后面的每个数进行比较，如果发现有比这个数更小的数，就重新确定这个最小数，并得到下标</li><li>当遍历到数组的最后时，就得到本轮最小数和小标</li><li>进行交换</li></ol></li><li><p>代码实现</p></li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">selectort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                  min =arr[j]; <span class="comment">//重置最小值</span></span><br><span class="line">                  arr[j] =arr[i];</span><br><span class="line">                  arr[i] =min;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">          System.out.println(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><ol start="4"><li>选择排序的时间复杂度n(n^2)</li></ol></li></ol><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ol><li><p>基本介绍</p><p>把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将他插入到有序表中的适当位置，使之成为新的有序表。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">           <span class="comment">//定义待插入的数</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">           <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">while</span> (insertIndex &gt;=<span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex])&#123;</span><br><span class="line">               arr[insertIndex +<span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">               insertIndex--;</span><br><span class="line">           &#125;</span><br><span class="line">           arr[insertIndex +<span class="number">1</span>] =insertVal;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2022/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
      <url>/2022/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="递归应用场景"><a href="#递归应用场景" class="headerlink" title="递归应用场景"></a>递归应用场景</h4><ol><li><p>迷宫问题（回溯）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">migong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建二维数组模拟迷宫</span></span><br><span class="line">        <span class="type">int</span>[][] map =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//使用1表示墙</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">7</span> ; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">8</span> ; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出地图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">8</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">7</span> ; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用递归开始找路</span></span><br><span class="line">        setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;  --------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">8</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">7</span> ; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//map代表地图</span></span><br><span class="line">    <span class="comment">//i， j表示从地图上那个位置开始出发</span></span><br><span class="line">    <span class="comment">//如果小球能到map[6][5]位置，则说明通路找到</span></span><br><span class="line">    <span class="comment">//迷宫策略：下-&gt;右-&gt;上-&gt;左，如果该点走不通再回溯</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">boolean</span> <span class="title function_">setWay</span><span class="params">(<span class="type">int</span>[][] map,<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;<span class="comment">//通路已经找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;<span class="comment">//如果这个点还没有走过</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123;<span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123;<span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123;<span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>阶乘问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阶乘问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n ==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factorial(n-<span class="number">1</span>)*n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>打印问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (n&gt;<span class="number">2</span>)&#123;</span><br><span class="line">         test(n-<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;n=&quot;</span>+n);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h4><ol><li>递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。</li></ol><h4 id="递归调用规则"><a href="#递归调用规则" class="headerlink" title="递归调用规则"></a>递归调用规则</h4><ol><li>当程序执行一个方法时，就会开辟一个独立的空间（栈）</li><li>方法的局部变量是独立的，不会相互影响，比如n变量</li><li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则就是无限递归</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li></ol><h4 id="八皇后问题（回溯算法）"><a href="#八皇后问题（回溯算法）" class="headerlink" title="八皇后问题（回溯算法）"></a>八皇后问题（回溯算法）</h4><ol><li><p>回溯算法的经典案例，在8X8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不处于同一行、同一列或同一斜线上，问有多少中摆法</p></li><li><p>代码实现(代码很简单，思考起来有点烦)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue8</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个max表示共有多少皇后</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 定义数组array,保存皇后放置位置的结果，比如 arr =&#123;0，4，7，5，2，6，1，3&#125;</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span>  <span class="title class_">int</span>[max];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Queue8</span> <span class="variable">queue8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue8</span>();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line">    <span class="comment">//特别注意：check 是每一次递归时，进入到check中都有 for(int i =0; i&lt;max; i++)</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max)&#123;<span class="comment">//n =8 表示八个皇后都放好</span></span><br><span class="line">            System.out.println(array[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+array[<span class="number">1</span>]+<span class="string">&quot; &quot;</span>+array[<span class="number">2</span>]+<span class="string">&quot; &quot;</span>+array[<span class="number">3</span>]+<span class="string">&quot; &quot;</span>+array[<span class="number">4</span>]+<span class="string">&quot; &quot;</span>+array[<span class="number">5</span>]+<span class="string">&quot; &quot;</span>+array[<span class="number">6</span>]+<span class="string">&quot; &quot;</span>+array[<span class="number">7</span>]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;max ; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后n,放到改行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n)) &#123;<span class="comment">//不冲突</span></span><br><span class="line">                <span class="comment">//接着放n+1个皇后，即开始递归</span></span><br><span class="line">                check(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行array[n]=i;即将第n个皇后，放置在本行的后移一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看当我们放置第n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //说明</span></span><br><span class="line"><span class="comment">            1.arrary[i] == arrary[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line"><span class="comment">            2.Math.abs(n-i)==Math.abs(arrary[n] -arrary[i]) 表示</span></span><br><span class="line"><span class="comment">             判断第n个皇后是否和第i皇后是否在同一斜线上</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n]-array[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2022/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
      <url>/2022/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><h4 id="栈的介绍"><a href="#栈的介绍" class="headerlink" title="栈的介绍"></a>栈的介绍</h4><ol><li>栈是一个先入后出的有序列表</li><li>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top）,另一端为固定的一端，称为栈底（Bottom）。</li><li>最先放入栈中的元素在栈底，最后放入的元素在栈顶。最后放入的元素先删除，最先放入的元素后删除。</li></ol><h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><ol><li><p>思路分析</p><ol><li>定义一个top来表示栈顶，初始化为-1</li><li>入栈操作，当有数据加入时，top++;stack[top]&#x3D;data;</li><li>出栈操作，int value&#x3D;stack[top];top–;return value</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Arraystack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//数组模拟栈，数据放到数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//top 表示栈顶 初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Arraystack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//沾满</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> valule)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = valule;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span>top;</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span>  value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，从栈顶开始显示数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>top; i&gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="栈实现综合计算器"><a href="#栈实现综合计算器" class="headerlink" title="栈实现综合计算器"></a>栈实现综合计算器</h4><ol><li><p>思路分析</p><ol><li>准备两个栈，一个数栈：用来存放数据 一个符号栈：用来存放运算符</li><li>通过一个index值（索引），来遍历我们的表达式</li><li>如果我们发现是一个数字，就直接入数栈</li><li>如果是符号<ol><li>如果当前的符号栈是空，就直接入栈</li><li>如果符号栈不空，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就需要从数栈中pop出两个数，在从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的符号入符号栈，如果当前的符号的优先级大于栈中的操作符，就直接入符号栈</li></ol></li><li>当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并进行运算</li><li>最后在数栈的只有一个数字，就是表达式的结果</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span><span class="string">&quot;7+2*6-2&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个栈，数栈，符号栈、</span></span><br><span class="line">        <span class="type">Arraystack2</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arraystack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Arraystack2</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arraystack2</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义需要的相关变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span><span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//依次得到expression的每一个字符</span></span><br><span class="line">            ch = expression.substring(index, index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断ch是什么，然后做相应的处理</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isOper(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span> (!operStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//如果符号栈不为空，就进行比较</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.priority(ch)&lt;= operStack.priority(operStack.peek()))&#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        numStack.push(res);</span><br><span class="line"></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果当前的操作符的优先级大于栈顶的操作符，就直接入栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果符号栈为空</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是数</span></span><br><span class="line">                numStack.push(ch-<span class="number">48</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index&gt;=expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算结束</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res);<span class="comment">//入栈</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span>+numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建一个栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arraystack2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//数组模拟栈，数据放到数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//top 表示栈顶 初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Arraystack2</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//沾满</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> valule)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = valule;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，从栈顶开始显示数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper ==<span class="string">&#x27;*&#x27;</span> || oper==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oper==<span class="string">&#x27;+&#x27;</span> || oper ==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="keyword">public</span>  Boolean <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==<span class="string">&#x27;+&#x27;</span> || val==<span class="string">&#x27;-&#x27;</span>||val==<span class="string">&#x27;*&#x27;</span> || val==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res =num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res =num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res =num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res =num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="栈的三种表达式"><a href="#栈的三种表达式" class="headerlink" title="栈的三种表达式"></a>栈的三种表达式</h4><h5 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h5><ol><li>前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前</li><li>如：（3+4）*5-6对应的前缀表达式就是- * + 3 4 5 6 从右向左开始扫描</li><li></li></ol><h5 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h5><ol><li>中缀表达式 就是我们常见的运算表达式</li><li>对于计算机来说，中缀表达式很难表示</li></ol><h5 id="后缀表达式（逆波兰表达式）"><a href="#后缀表达式（逆波兰表达式）" class="headerlink" title="后缀表达式（逆波兰表达式）"></a>后缀表达式（逆波兰表达式）</h5><ol><li><p>与前缀表达式相似，只是运算符位于操作数之后</p></li><li><p>如：（3+4）<em>5 - 6 对应的后缀表达式就是3 4 + 5</em> 6 -</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个逆波兰表达式</span></span><br><span class="line">        <span class="comment">//（3+4）X 5-6 =&gt;3 4 + 5 X 6 -</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;3 4 + 5 * 6 -&quot;</span>;</span><br><span class="line">        <span class="comment">//1.先将&quot;3 4 + 5 X 6 -&quot; 放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2.将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line">        System.out.println(rpnList);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span>calculate( rpnList);</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符 放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span> &#123;</span><br><span class="line">        <span class="comment">//将suffixExpression 分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split</span><br><span class="line">        ) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; ls)</span> &#123;</span><br><span class="line">        <span class="comment">//创建栈，</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//利用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(res + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
      <url>/2022/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="单链表介绍和内存分布"><a href="#单链表介绍和内存分布" class="headerlink" title="单链表介绍和内存分布"></a>单链表介绍和内存分布</h4><ul><li>链表是以节点的方式来存储的</li><li>每个节点包含data域，next域：指向下一个节点</li><li>链表的各个节点不一定是连续存储</li><li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定。</li></ul><h4 id="单链表的创建和遍历"><a href="#单链表的创建和遍历" class="headerlink" title="单链表的创建和遍历"></a>单链表的创建和遍历</h4><h5 id="带头节点的单链表"><a href="#带头节点的单链表" class="headerlink" title="带头节点的单链表"></a>带头节点的单链表</h5><ol><li><p>head节点 不存放具体数据，作用是表示单链表的头</p></li><li><p>单链表的最后一个节点next域指向为NULL</p></li><li><p>单链表的创建</p><ol><li>先创建一个head头节点</li><li>后面我们每添加一个节点，就直接加入到链表的最后</li></ol></li><li><p>遍历</p><ol><li>通过一个辅助遍历，帮助遍历整个链表</li></ol></li><li><p>单链表的代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//进行测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        <span class="type">Heronode</span> <span class="variable">heronode1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Heronode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">Heronode</span> <span class="variable">heronode2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Heronode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">Heronode</span> <span class="variable">heronode3</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Heronode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        Heronode heronode4=<span class="keyword">new</span> <span class="title class_">Heronode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        <span class="type">SingleLinked</span> <span class="variable">singleLinked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinked</span>();</span><br><span class="line">        singleLinked.add(heronode1);</span><br><span class="line">        singleLinked.add(heronode2);</span><br><span class="line">        singleLinked.add(heronode3);</span><br><span class="line">        singleLinked.add(heronode4);</span><br><span class="line"></span><br><span class="line">        singleLinked.list();</span><br><span class="line"></span><br><span class="line">        singleLinked.addByOrder(heronode2);</span><br><span class="line">        singleLinked.addByOrder(heronode1);</span><br><span class="line">        singleLinked.addByOrder(heronode3);</span><br><span class="line">        singleLinked.addByOrder(heronode4);</span><br><span class="line"></span><br><span class="line">        singleLinked.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类用来管理节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinked</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化一个头节点，头节点不能动，不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> Heronode head=<span class="keyword">new</span> <span class="title class_">Heronode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    添加节点到单链表</span></span><br><span class="line"><span class="comment">    当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">    1.找到当前链表的最后一个节点</span></span><br><span class="line"><span class="comment">    2.将最后这个节点的next 指向新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Heronode heronode)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个temp辅助遍历</span></span><br><span class="line">        <span class="type">Heronode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到最后，就将temp后移</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最后一个节点的next 指向新的节点</span></span><br><span class="line">        temp.next=heronode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">//如果前面有这个排名，则添加失败，并给出提示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(Heronode heronode)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Heronode</span> <span class="variable">temp</span> <span class="operator">=</span>head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no&gt;heronode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span> (temp.next.no==heronode.no)&#123;</span><br><span class="line">                flag =<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp =temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加的排名重复&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.next=heronode;</span><br><span class="line">            heronode.next=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">Heronode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            <span class="comment">//将temp后移</span></span><br><span class="line">            temp =temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode,每个HeroNode对象是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heronode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span>  Heronode next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heronode</span><span class="params">(<span class="type">int</span> hNo,String hName, String hNickname)</span>&#123;</span><br><span class="line">        no=hNo;</span><br><span class="line">        name=hName;</span><br><span class="line">        nickname=hNickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Heronode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>从单链表中删除节点</p><ul><li>我们先找到需要删除的节点的前一个节点</li><li>temp.next &#x3D;temp.next.next</li></ul></li></ol><h4 id="单链表面试题（新浪、百度、腾讯）"><a href="#单链表面试题（新浪、百度、腾讯）" class="headerlink" title="单链表面试题（新浪、百度、腾讯）"></a>单链表面试题（新浪、百度、腾讯）</h4><h5 id="获取单链表中节点的个数（如果是带头节点的链表，不统计头节点）"><a href="#获取单链表中节点的个数（如果是带头节点的链表，不统计头节点）" class="headerlink" title="获取单链表中节点的个数（如果是带头节点的链表，不统计头节点）"></a>获取单链表中节点的个数（如果是带头节点的链表，不统计头节点）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(Heronode head)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">Heronode</span> <span class="variable">cur</span> <span class="operator">=</span>head.next;<span class="comment">//这里没有统计头节点</span></span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">           length++;</span><br><span class="line">           cur = cur.next;<span class="comment">//遍历</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>  length;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="查找单链表中的倒数第K个节点【新浪面试题】"><a href="#查找单链表中的倒数第K个节点【新浪面试题】" class="headerlink" title="查找单链表中的倒数第K个节点【新浪面试题】"></a>查找单链表中的倒数第K个节点【新浪面试题】</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  思路</span></span><br><span class="line"><span class="comment">  1.编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">  2.index 表示是倒数第index节点</span></span><br><span class="line"><span class="comment">  3.先把链表从头到尾遍历，得到链表的总的长度getlength</span></span><br><span class="line"><span class="comment">  4.得到size后，我们从链表的第一个开始遍历（size-index）个，就可以得到</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">static</span> Heronode <span class="title function_">findeLastIndexNode</span><span class="params">(Heronode head,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span>  <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span>getLength(head);<span class="comment">//链表的长度</span></span><br><span class="line">      <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">          <span class="keyword">return</span>  <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Heronode</span> <span class="variable">temp</span> <span class="operator">=</span>head.next;</span><br><span class="line">      <span class="comment">//for循环定位到index</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt;size-index ; i++) &#123;</span><br><span class="line">          temp=temp.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>  temp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="单链表的反转-腾讯面试题"><a href="#单链表的反转-腾讯面试题" class="headerlink" title="单链表的反转[腾讯面试题]"></a>单链表的反转[腾讯面试题]</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将单链表反转</span></span><br><span class="line"> <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">reversetLsit</span><span class="params">(Heronode head)</span>&#123;</span><br><span class="line">     <span class="comment">//判断当前链表是否为空，或者只有一个节点</span></span><br><span class="line">     <span class="keyword">if</span> (head.next==<span class="literal">null</span> || head.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//定义一个辅助的指针</span></span><br><span class="line">     <span class="type">Heronode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">     <span class="type">Heronode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="type">Heronode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heronode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">     <span class="keyword">while</span> (cur !=<span class="literal">null</span>)&#123;</span><br><span class="line">         next=cur.next;</span><br><span class="line">         reverseHead.next=cur;</span><br><span class="line">         cur.next=reverseHead.next;</span><br><span class="line">         cur=next;<span class="comment">//让cur后移</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//将head.next 指向reversehead.next 实现单链表的反转</span></span><br><span class="line">     head.next = reverseHead.next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul><li><p>分析双向链表的遍历，添加，修改，删除的操作思路</p><ol><li>遍历方法和单链表一样，只是可以向前，也可以向后查找</li><li>添加（默认添加到双向链表的最后）<ol><li>先找到双向链表的最后这个节点</li><li>temp.next&#x3D;newHeroNode</li><li>newHeroNode.pre&#x3D;temp</li></ol></li><li>修改 同单向链表</li><li>删除<ol><li>因为是双向链表，可以实现自我删除某个节点</li><li>直接找到要删除的这个节点，比如temp</li><li>temp.pre &#x3D;temp.next</li><li>temp.next.pre&#x3D;temp.pre;</li></ol></li></ol></li><li><p>双向链表的代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinked</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//进行测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">heronode1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">heronode2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">heronode3</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        Hero heronode4=<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">doubleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.add(heronode1);</span><br><span class="line">        doubleLinkedList.add(heronode2);</span><br><span class="line">        doubleLinkedList.add(heronode3);</span><br><span class="line">        doubleLinkedList.add(heronode4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">newHexo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>, <span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line">        doubleLinkedList.update(newHexo);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化头节点</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">Hero</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">public</span>  Hero <span class="title function_">getHead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历双向链表</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            <span class="comment">//将temp后移</span></span><br><span class="line">            temp =temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加双向链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Hero hero)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个temp辅助遍历</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到最后，就将temp后移</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最后一个节点的next 指向新的节点</span></span><br><span class="line">        temp.next=hero;</span><br><span class="line">        hero.pre=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改双向链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Hero hero)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">temp</span> <span class="operator">=</span>head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == hero.no)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.name = hero.name;</span><br><span class="line">            temp.nickname =hero.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;信息有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">temp</span> <span class="operator">=</span>head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除的节点不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> Hero next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> Hero pre;<span class="comment">//指向前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h4><h6 id="约瑟夫问题（约瑟夫环）"><a href="#约瑟夫问题（约瑟夫环）" class="headerlink" title="约瑟夫问题（约瑟夫环）"></a>约瑟夫问题（约瑟夫环）</h6><p>约瑟夫问题描述：设编号1，2….n的n个人围坐一圈，约定编号为k(1&lt;&#x3D;k&lt;&#x3D;n)的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的n那个人又出列，依次类推，直到所有人都出列为止，由此产生一个出队编号的序列。</p><h6 id="约瑟夫问题的代码实现"><a href="#约瑟夫问题的代码实现" class="headerlink" title="约瑟夫问题的代码实现"></a>约瑟夫问题的代码实现</h6><ol><li><p>构建一个单向环形链表思路</p><ol><li>，先创建第一个节点，让first指向该节点，并形成环形</li><li>后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可。</li></ol></li><li><p>遍历环形链表</p><ol><li>先让一个辅助指针（变量）temp，指向first节点</li><li>然后通过一个while循环遍历该环形链表即可 temp.next &#x3D;first 结束</li></ol></li><li><p>约瑟夫问题出队列</p><ol><li><p>需要创建一个辅助指针helper，事先指向环形链表的最后节点</p></li><li><p>当小孩报数时，让first和辅助指针同时移动m-1次</p></li><li><p>这时候将first指向的小孩节点出圈</p><p>first &#x3D;first.next</p><p>helper.next&#x3D;first</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Josefu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CircleSingleLinkedlist</span> <span class="variable">circleSingleLinkedlist</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedlist</span>();</span><br><span class="line">        circleSingleLinkedlist.addBoy(<span class="number">5</span>);<span class="comment">//加入五个小孩节点</span></span><br><span class="line">        circleSingleLinkedlist.showBoy();</span><br><span class="line"></span><br><span class="line">        circleSingleLinkedlist.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建环形单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedlist</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加小孩节点，构建成一个环形的链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums的值不争取&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//辅助指针，帮助构建环形链表</span></span><br><span class="line">        <span class="comment">//使用for循环来创建环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据编号，创建小孩节点</span></span><br><span class="line">            <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//first,不能动 使用辅助指针</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;编号是%d\n&quot;</span>, curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">//说明已经编列完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext();<span class="comment">//指针后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo,<span class="type">int</span> countNum,<span class="type">int</span> nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first==<span class="literal">null</span> || startNo&lt; <span class="number">1</span> || startNo&gt;nums)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误，请重新输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建辅助指针，帮助小孩出圈</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() ==first)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//报数前，先让first和helper移动k-1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;startNo-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小孩报数时，让first和helper指针同时移动m-1次，然后出圈</span></span><br><span class="line">        <span class="comment">//这里是一个循环操作</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper == first) &#123;<span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让first和helper指针同时的移动countNum -1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;countNum-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">                first=first.getNext();</span><br><span class="line">                helper=helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时first指向的小孩节点出圈</span></span><br><span class="line">            System.out.println(first.getNo());</span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最后留的&quot;</span>+first.getNo());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no =no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2022/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2022/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h3><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><ol><li><p>线性结构作为最常用的数据结构，其特点是<strong>数据元素之间存在一对一</strong>的线性关系</p></li><li><p>线性结构有两种不同的存储结构，即<strong>顺序存储结构（数组）和链式存储结构（链表）</strong>。顺序存储的线性表称为顺序表，顺序表中的<strong>存储元素是连续</strong>的</p></li><li><p>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息</p></li><li><p>线性结构常见的有：数组、队列、链表和栈。</p></li></ol><h4 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4><ol><li>非线性结构包括：二维数组、多维数组、广义表、树结构、图结构</li></ol><h3 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a>稀疏数组和队列</h3><h4 id="稀疏sparsearray数组"><a href="#稀疏sparsearray数组" class="headerlink" title="稀疏sparsearray数组"></a>稀疏sparsearray数组</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><ol><li>当一个数组中大部分元素是零，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</li><li>稀疏数组的处理方法：<ol><li>计录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ol></li></ol><h5 id="稀疏数组的转换"><a href="#稀疏数组的转换" class="headerlink" title="稀疏数组的转换"></a>稀疏数组的转换</h5><ol><li>稀疏数组共有三列，第一列保存行信息，第二列保存列信息，第三列保存有效值</li><li>稀疏数组的第一行，分别保存该二维数组总共有多少行多少列，多少个有效值（n）</li><li>下面的n行分别对应n个有效值的行列信息和有效值的信息</li></ol><h5 id="稀疏数组代码实现"><a href="#稀疏数组代码实现" class="headerlink" title="稀疏数组代码实现"></a>稀疏数组代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [][] char1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">5</span>];<span class="comment">//定义一个五行五列的二维数组</span></span><br><span class="line">        char1[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        char1[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row:char1</span><br><span class="line">             ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a: row</span><br><span class="line">                 ) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将二维数组转成稀疏数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;char1.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;char1[i].length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (char1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//定义稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArray[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">2</span>]=sum;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;char1.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;char1[i].length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (char1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sparseArray[count][<span class="number">0</span>]=i;</span><br><span class="line">                    sparseArray[count][<span class="number">1</span>]=j;</span><br><span class="line">                    sparseArray[count][<span class="number">2</span>]=char1[i][j];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row:sparseArray</span><br><span class="line">             ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data: row</span><br><span class="line">                 ) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//稀疏数组转换成二维数组</span></span><br><span class="line">        <span class="type">int</span> char2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArray[<span class="number">0</span>][<span class="number">0</span>]][sparseArray[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;sparseArray.length ; i++) &#123;</span><br><span class="line">          char2[sparseArray[i][<span class="number">0</span>]][sparseArray[i][<span class="number">1</span>]]=sparseArray[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row:char2</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a: row</span><br><span class="line">            ) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="队列的应用场景"><a href="#队列的应用场景" class="headerlink" title="队列的应用场景"></a>队列的应用场景</h5><ol><li>银行排队叫号系统</li></ol><h5 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h5><ol><li>队列是一个有序列表，可以用<strong>数组或是链表</strong>来实现</li><li>遵循<strong>先入先出</strong>的原则：先存入队列的数据，要先取出。后存入的要后取出</li></ol><h5 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h5><ol><li><p>编写一个ArrayQueue类 </p></li><li><p>定义属性：maxSize:最大容量；front:队列头；rear:队列尾；arr[]：存放数据，模拟队列</p></li><li><p>创建队列的构造器</p></li><li><p>判断队列是否满</p></li><li><p>判断队列是否为空</p></li><li><p>添加数据到队列（int n）要先判断队列是否是满的</p></li><li><p>数据出队列  要先判断队列是否空 通过抛出异常</p></li><li></li><li><p>显示队列数据</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">ArrayQueue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//数组最大的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxsize)</span>&#123;</span><br><span class="line">        maxSize = arrMaxsize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear]=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空，不能遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目前数组没有达到复用的效果，改进：使用算法将该数组改成一个环形数组</p></li></ol><h5 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h5><ol><li><p>front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素</p></li><li><p>rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，空出一个空间作为约定。</p></li><li><p>当队列满时，条件是（rear+1）%maxSize&#x3D;front </p></li><li><p>当队列为空的条件 rear&#x3D;front  </p></li><li><p>队列中有效数据的个数（rear+maxSize-front）%maxSize </p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">CircleArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleArray</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        front=(front+<span class="number">1</span>)%maxSize;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt;front+size() ; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear+maxSize - front)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
